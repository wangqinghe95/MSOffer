# MSOffer
[剑指 offer 习题](https://leetcode-cn.com/problemset/lcof/)

# MSOffer-1

start by 2021.05.19
+ 03：找出数组中重复的数字，任意一个即可
+ 04：在一个从左向右，从上向下递增的数组中查找指定数字
+ 05：将一个字符串中的空格替换成指定字符串
+ 06：从尾部向头部打印链表
+ 07：先序中序建树
+ 09：两个栈模拟队列的插入和删除
+ 10-I：递归和迭代实现斐波那契函数
+ 10-II： 青蛙上台阶-斐波那契函数变形
+ 11：区域有序数组的最小值
+ 12：dfs+剪支
+ 13: BFS 遍历（队列）+ DFS 遍历（递归）
+ 14-I：动态规划求一个数组合之积最大
+ 14-II：贪心算法（参杂大数）求一个数组合之积最大
+ 15：求一个数的二进制中有 1 的个数
+ 16：位运算实现快速幂思路
+ 17：dfs + 全排列求 1-10 n 位替换的所有情况
+ 18：删除链表的指定值节点
+ 19：字符串匹配：动态规划、递归（待实现）、NFA（待实现）
+ 20：判断数字有效性：有限状态机、直接判断（代码未通过）
+ 21：奇数在前半段，偶数在后半段：用快排思路
+ 22：找链表的倒数第K个节点：快慢指针
+ 24：反转链表：原地反转
+ 25：合并链表：递归+迭代
+ 26：判断树B是否是树A的子树：递归遍历
+ 27：二叉树的镜像：先序遍历，然后交换左右结点
+ 28：对称二叉树的判断：递归和迭代实现
+ 29：顺时针打印二维数组
+ 30：实现一个最小栈
+ 31：验证如栈出栈顺序
+ 32-I：层次遍历二叉树，所有数组保存到一个数组
+ 32-II：层次遍历二叉树，一行保存到一个数组
+ 32-III：之字形顺序打印二叉树，一行保存到一个数组
+ 33：验证二叉搜索树的后序遍历
+ 34：DFS 和 BFS 记录二叉树的遍历路径
+ 35：复杂链表的复制，带了一个随机结点指向整个链表的随机结点。
+ 36：二叉搜索树转换为双向链表
+ 37：序列化和反序列化一棵树
+ 38：字符串的全排列
+ 39：数组中出现次数超过一半的数字
+ 40：最小的k个数：堆排序和快排
+ 41：数据流的中位数：大顶堆和小顶堆的使用
+ 42：连续子数组最大和：动态规划，线段树（待补充）
+ 43：1~n中1出现的次数
+ 44：数字序列中某一位数的位置：找规律
+ 45：一串数字组成最小的数字：快排和内置sort函数
+ 46：将数字转化为对应的字母：dp和递归，类同与上台阶
+ 47：二维数组的dp、DFS
+ 48：最长不含重复字串
+ 49：丑数：dp算法
+ 50：第一次出现的次数为1的字符
+ 51：求逆序对，归并排序
+ 52：两个链表公共结点问题：hash 和 双指针
+ 53-I：排序数组查找一个数字的范围
+ 53 - II. 0～n-1中缺失的数字：hash方法、数学、二分
+ 54：二叉搜索树第k大结点：中序遍历
+ 55-I：求树的深度：层次遍历，先序遍历
+ 55-II：判断是否是平衡二叉树
+ 56-I：所有数字出现2次，只有一个数字出现1次，求这个数字
+ 56-II：所有数字出现3次，只有一个数字出现1次，求这个数字
+ 57：双指针
+ 57-II：滑动窗口（本质也是双指针）
+ 58-I：反转单词
+ 58-II：左旋字串
+ 59-I：滑动窗口的最大值
+ 50-II：队列的最大值
+ 60：色子点数和概率（dp）
+ 61：五张扑克牌组成一个顺子
+ 62：约瑟环
+ 63：股票最大利润
+ 64：不是用if、whie、：来计算 1～n的和
+ 65：不用加减乘除做加法
+ 66：构建乘积数组
+ 67：字符串转数字
+ 68-I：二叉搜索树的最近公共祖先
+ 68-II：二叉树的最近公共祖先

ending in 20210925

---
# MSOffer-2
+ 1：整数除法：不使用 /,*,% 等符号
+ 2：二进制加法：字符串模拟二进制加法
+ 3：前n个数字二进制1的个数字：计算数字中1的个数
+ 4：一个数组中只有一个数出现过一次，其余三次出现过三次，找出这个数
+ 7：数组中和为0的三个数
+ 8：和大于等于target的最短子数组
+ 9：乘积小于K的子数组：双指针
+ 10：和为K的子数组个数，数组中可以有负数：前缀和
+ 11：转化为和为0的最长子数组：前缀和
+ 12：左右两边子数组和相等
+ 13：返回一个矩阵的特定范围的和
+ 14：变位词：单词位置可以变化，但是单词种类和数量需要对应上的字符串
+ 15：求所有变位词的起始位置
+ 16：一个字符串最长不重复子串
+ 17：在 s 字符串中找到一个包含 t 所有字符的字串
+ 18：去掉非数字和字母的字符，判断该串是否是一个回文串
+ 19：当遇到一个非对称的回文字符串时，去判断下一个字符串是否是回文串
+ 20：一个字符串回文字串的个数，找到回文中心，向两边拓展看是否有回文子串
+ 21：删除倒数第 n 个节点：使用哨兵指针
+ 22：寻找循环链表的第一个入口
+ 23：找两个相交链表的相交节点
+ 24：反转链表：递归和迭代
+ 25：两个链表加减：先反转，再尾插 && 辅助栈
+ 26：链表两分后再合并
+ 27：回文链表：找到中间链表，反转中间节点到尾部节点，开始比较，再将反转的部分还原
+ 28：将多级双向链表整合成一个单链表
+ 29：向一个非递减但起始节点未定的循环链表插入一个节点仍然保持非递减状态
+ 30：设计一个插入删除和查找的时间复杂度都是O(1)的类
+ 31：最近最少使用缓存：双向链表 + hash
+ 32：有效的变位词：hash 表记录出现的字母的次数即可
+ 33：变位词组：一个字符串数组中找到变位词放在一起返回
+ 34：单词比较：根据自定义的字典序，比较n个单词是否符合该字典序
+ 35：最小时间差：保存在vector<string>中的时间，找出其中差值最小的时间
+ 36：使用栈去模式后缀表达式
+ 37：小行星碰撞：正数在前负数在后时发生碰撞
+ 38：找到后面比当天温度高的一天和今天相差的天数
+ 39：求立方图的最大面积-单调栈
+ 40：39的深入题
+ 41：队列实现滑动窗口
+ 42：滑动窗口简单使用
+ 43：完全二叉树的插入
+ 44：二叉树的层次遍历
+ 45：二叉树的后序和层次遍历
+ 46：二叉树的后序遍历变形
+ 47：二叉树剪枝
+ 48：序列化和反序列化二叉树
+ 49：树的遍历
+ 50：向下路径之和等于某个值
+ 51：二叉树求最大的路径和
+ 52：中序遍历将二叉树展开成只要右孩子的链表
+ 53：找指定节点的中序遍历的下一个节点
+ 54：将二叉搜索树中所有节点的值修改为它右子树的所有节点的和
+ 55：迭代和递归实现中序遍历
+ 56：二叉搜索树的递归和迭代中序遍历
+ 57：滑动窗口+set
+ 58：以一个时间段为单位的数据插入
+ 59：数据流的中位数：最小堆，但是自己实现的最小堆时间复杂度过大
+ 60：统计一个数组中前k个出现次数最多的数字
+ 61：k个和最小且来自于不同数组的元素组合